// ###################################################################
// PROJECT: SPATIAL SIMULATION OF VIRAL SPREAD WITHIN A 2D LAYER OF CELLS
//
// Corefile for the functions to simulate the layer of cells and the
// virions considered in the spatial simulation
// @Authors: Peter Kumberger & Frederik Graw
// ###################################################################

// ###############################################################
// MAIN HEADER FILES
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <math.h>
#include <list>
#include <R.h>
#include <Rmath.h>
#include <algorithm>    // std::random_shuffle
#include <vector>       // std::vector
#include <ctime>        // std::time
#include <cstdlib>      // std::rand, std::srand
#include <unistd.h>     // std::usleep
#include <iterator>     // std::distance

using namespace std;

// OPTIONAL: include a file with some basic parameters, which can
// be generated by a separate R-file. Paths to the files might have
// to be adapted
#include HCVSpread_parameter.h
#include rand_generator.h


// ###############################################################
// Define the names of the output streams (ViralSpread_parameter.h)
// What kind of data should be saved?
//ofstream outHEP(FNAME, ios::out);
//ofstream outVIR(FNAME, ios::out);
//ofstream outHEPstat(FNAME, ios::out);
//ofstream outHEPana(FNAME, ios::out);


// ###############################################################
// DEFINITION OF STRUCTURES/ CLASSES NEEDED

// general structures
struct _Vector{
	double vec[15];
};
typedef struct _Vector Vector;

struct _GridPos{
	int vec[2];
};
typedef struct _GridPos GridPos;

Vector setZerovector(Vector vecTor){
	for (int i=0;i<15;i++){
		vecTor.vec[i]=0;
	}
	return vecTor;
}

// main class cell - hepatocyte arranged in layers
class hepatocyte{
public:
	double position[2];					// (x,y) position of the nucleus of the hepatocyte
	double radius;						// x-coordinate distance to next neighbour membrane (width/2)
	double distance;					// y-coordinate distance to the sinusoid (height/2)
	int id;								// identification number of each cell
    int infectType;                     // Cell infected by cell to cell(2) or free diffusion(3) (or both(4)). Initial infection(1), special marker (5)
    int clusterType;                    // Affiliation of cell
	int status;                         // 0: uninfected, 1: newly infected, 2: infectious, 3: empty, 4: infected (not infectious)
	int statusTime;						// time point at which the hepatocyte switched to this status
	int age;							// age of the hepatocyte in time steps
	int deathTime;						// number of time steps in relation to statusTime at which the hepatocyte will die
    double IntraVirusRNA;                 // Intraviral positive stranded HCV RNA concentration
	/* additional parameters needed */
	int IT;								// time of infection
	int IIT;							// time starting viral production
	// class specific methods:
    virtual void setPosition(int id){
        position[0]=(id-1)%(2*LENGTH_SIDE-1);
        position[1]=floor((id-1)/(2*LENGTH_SIDE-1));
    }
	virtual void setDistRad(double d,double r){
		distance=d;
		radius=r;
	}
	virtual void setID(int i){
		id=i;
	}
    virtual GridPos getPosition(int id){
        GridPos posvec;
        posvec.vec[0]=(id-1)%(2*LENGTH_SIDE-1);
        posvec.vec[1]=floor((id-1)/(2*LENGTH_SIDE-1));
        return posvec;
    }
	virtual double getRadius(){
		return radius;
	}
	virtual void setStatus(int i){
		status=i;
	}
	virtual void setStatusTime(double t){
		statusTime=t;
	}
	virtual void setIT(int t){
		IT=t;
	}
	virtual void setIIT(int t){
		IIT=t;
	}
	virtual void setDeathTime(int t){
		deathTime=t;
	}
	virtual void updateAge(){
		age++;
	}
    virtual void setIntraVirusRNA(double R0){
        		IntraVirusRNA=R0;
    }
    virtual void updateIntraVirusRNA(double rate_prod, double Rcap, double rate_export, double rate_degrade){
            IntraVirusRNA=IntraVirusRNA+(rate_prod*IntraVirusRNA*(1-(IntraVirusRNA/Rcap)))-(rate_export*IntraVirusRNA);
    }
    virtual void reduceIntraVirusRNA(double red, double R0){
        IntraVirusRNA=IntraVirusRNA-red;
        if (IntraVirusRNA<R0){
            IntraVirusRNA=R0;
        }
    }
    virtual void setInfectType(int a){
        infectType=a;
    }
    virtual void setClusterType(int a){
        clusterType=a;
    }
};

// main class virus - extracellular virus concentration per "cell"
class virus{
public:
	double position[2];					// (x,y) position of the nucleus of the hepatocyte
	double radius;						// x-coordinate distance to next neighbour membrane (width/2)
	double distance;					// y-coordinate distance to the sinusoid (height/2)
	int id;								// identification number of each cell
	double conc;						// viral concentration on this spot
	double concII;						// viral concentration for update (diffusion of viral particles)
	// class specific methods:
	virtual void setPosition(int id){
		position[0]=(id-1)%(2*LENGTH_SIDE-1);
		position[1]=floor((id-1)/(2*LENGTH_SIDE-1));
	}
	virtual void setDistRad(double d,double r){
		distance=d;
		radius=r;
	}
	virtual void setID(int i){
		id=i;
	}
	virtual void setConc(double c){
		conc=c;
	}
	virtual void setConcII(double c){
		concII=c;
	}
	virtual void updateConc(){
		conc=concII;
	}
	virtual void setConcIFN(double c){
		IFNconc=c;
	}
	virtual void setConcIFNII(double c){
		IFNconcII=c;
	}
	virtual void updateConcIFN(){
		IFNconc=IFNconcII;
	}
    virtual GridPos getPosition(int id){
        GridPos posvec;
        posvec.vec[0]=(id-1)%(2*LENGTH_SIDE-1);
        posvec.vec[1]=floor((id-1)/(2*LENGTH_SIDE-1));
        return posvec;
    }
	virtual double getRadius(){
		return radius;
	}
	virtual void addVirus(double a){
		conc=conc+a;
	}
	virtual void subtractVirus(double a){
		conc=conc-a;
		if (conc<0){
			conc=0;
		}
	}
};

// ###############################################################


// ############################################################### // ###############################################################
// ###############################################################
// FUNCTIONS TO CALCULATE NEIGHBOURING NODES

// (1a.) Function to calculate ID from its position
int getID(int r, int c){
    int ID;
    ID = r+1+(2*LENGTH_SIDE-1)*(c);
    return ID;
}

// (1b.) Function which returns a vector with all possible neighbouring nodes of a specific node
vector<int> returnNeighbrs(int rpos, int cpos){
    vector<int> neighvec;
    for (int i=-1;i<2;i++){
        for (int j=-1;j<2;j++){
            if(i!=j){
                int ctest=cpos+i;
                int rtest=rpos+j;
                if ((rtest<2*LENGTH_SIDE-1)&&(ctest<2*LENGTH_SIDE-1)&&(ctest+rtest>=LENGTH_SIDE-1)&&(ctest+rtest<=3*(LENGTH_SIDE-1))&&(ctest>=0)&&(rtest>=0)){
                    neighvec.push_back(getID(rtest,ctest));  // stay within grid
                }
            }
        }
    }
    neighvec.erase(std::remove(neighvec.begin(), neighvec.end(), 0), neighvec.end());
    return neighvec;
}

// (1c.) Function to calculate the position of the node based on its ID
GridPos calcPosition(int id){
    GridPos posvec;
    posvec.vec[1]=floor((id-1)/(2*LENGTH_SIDE-1));
    posvec.vec[0]=(id-1)%(2*LENGTH_SIDE-1);
    return posvec;
}

// (1d.) Function to calculate a random id
int randID(vector<int> grid_id){
    int randID;
    usleep(1e6);                    // wait 1 second so that there is a new seed
    srand (time(NULL));
    vector<int>::iterator it;
    it=grid_id.begin();
    int ummy=rand()%grid_id.size();
    advance(it, ummy);
    randID=*it;
    return randID;
}

// (1e.) Function similar to R's sample function
// random generator function:
int myrandom (int i) { return rand()%i;}

vector<int> sample(vector<int> myvec) {
    srand ( unsigned ( time(0) ) );                             // Set.seed
    
    random_shuffle ( myvec.begin(), myvec.end() );              // using built-in random generator
    
    random_shuffle ( myvec.begin(), myvec.end(), myrandom);     // using myrandom
    
    return myvec;
}

// ############################################################### // ###############################################################
// ###############################################################
// CREATING THE 2D LAYER OF CELLS
// We assume a hexagonal layer of cells which are hexagonally shaped

// Function to initialize id vector for hexagonal grid
vector<int> initGrid(){
    int dummy=0;
    vector<int> ID_cells;
    for (int c=0; c<2*LENGTH_SIDE-1;c++) {
        if (c<LENGTH_SIDE) {
            for (int r=LENGTH_SIDE-c-1; r<2*LENGTH_SIDE-1; r++) {
                ID_cells.push_back(getID(r,c));
            }
        }
        else if (c>=LENGTH_SIDE) {
            dummy++;
            for (int r=0; r<2*LENGTH_SIDE-dummy-1; r++) {
                ID_cells.push_back(getID(r,c));
            }
        }
    }
    return ID_cells;
}


// Array of pointers pointing to the individual hepatocytes
class hepatocyte *hepaticlayer[(2*LENGTH_SIDE-1)*(2*LENGTH_SIDE-1)-LENGTH_SIDE+1]; // largest ID = (2*LENGTH_SIDE-1)^2-LENGTH_SIDE+1

// Function to initialize the hepaticlayer
void initHepLayer(vector<int> grid_id){
    int counter;
    counter=grid_id.size();                            // number of hepatocytes
    Rprintf(" %d \n",grid_id.size());
    vector<int>::iterator j;
    j=grid_id.begin();                                 // first id
    while (counter>0) {
        hepaticlayer[*j]=new hepatocyte();              // initialize the cells of the upper and lower hepaticlayer
		hepaticlayer[*j] -> setStatus(0);				// define them as uninfected
		hepaticlayer[*j] -> setStatusTime(0);			// define statusTime to 0
		hepaticlayer[*j] -> setIT(0);					// define time of infection to 0
		hepaticlayer[*j] -> setIIT(0);                  // define time to get infectious to 0
		hepaticlayer[*j] -> setID(*j);                  // start Cell ID numbering with 1
		hepaticlayer[*j] -> setPosition(*j);			// additionally define the position of the cell in coordinates
        hepaticlayer[*j] -> setInfectType(0);
        hepaticlayer[*j] -> setClusterType(0);
		hepaticlayer[*j] -> setIntraVirusRNA(0);
        counter--;
        j++;
	}
}

// Function to reset the hepaticlayer for a new simulation run with the same parameters
list <int> resetHepLayer(vector<int> grid_id, list<int> E, double perc_empty, double *dummy, double prolif_time){
    double t_prolif;
    int counter;
    counter=grid_id.size();                            // number of hepatocytes
    vector<int>::iterator j;
    j=grid_id.begin();                                 // first id
    while (counter>0) {
        randbin(dummy,perc_empty);
        if (*dummy==1){
            hepaticlayer[*j] -> setStatus(3);    // Initiate empty cell
            E.push_back((*hepaticlayer[*j]).id);
        }
        else {
            hepaticlayer[*j] -> setStatus(0);    // Initiate uninfected cell
        }
        randnorm(dummy,prolif_time,0.1*prolif_time);
        t_prolif=*dummy;
		hepaticlayer[*j] -> setStatusTime(t_prolif);
        hepaticlayer[*j] -> setInfectType(0);
        hepaticlayer[*j] -> setClusterType(0);
		hepaticlayer[*j] -> setIntraVirusRNA(0);
        counter--;
        j++;
    }
    return(E);
}

// Frame for the concentration of the viral load per field -> based on the calculated probability distribution
// Frame contains the number of viral particles per square
class virus *viralGrid[(2*LENGTH_SIDE-1)*(2*LENGTH_SIDE-1)-LENGTH_SIDE+1];  // biggest ID = (2*LENGTH_SIDE-1)^2-LENGTH_SIDE+1


// Function to initialize the viralGrid
void initViralGrid(vector<int> grid_id){
    int counter;
    counter=grid_id.size();                            // number of hepatocytes
    vector<int>::iterator j;
    j=grid_id.begin();                                 // first id
    while (counter>0) {
		viralGrid[*j]=new virus();
		viralGrid[*j] -> setConc(0);
		viralGrid[*j] -> setConcII(0);
		viralGrid[*j] -> setPosition(*j);
		viralGrid[*j] -> setID(*j);
        counter--;
        j++;
	}
}

// Function to reset the viral grid for a new simulation run with the same parameters
void resetViralGrid(vector<int> grid_id){
    int counter;
    counter=grid_id.size();                            // number of hepatocytes
    vector<int>::iterator j;
    j=grid_id.begin();                                 // first id
    while (counter>0) {
        viralGrid[*j] -> setConc(0);
		viralGrid[*j] -> setConcII(0);
        counter--;
        j++;
	}
}


// ############################################################### // ###############################################################
// ############################################################### // ###############################################################

// ############################################################### // ###############################################################
// FUNCTION FOR CELL-DYNAMICS

// (2a.) Function to calculate the probability of initiating a new infectious cell at time t
double probInit(int t,double init_exp_rate,double trunc_time){
    double prob_init = 0.0;
    
    prob_init = init_exp_rate*exp(-init_exp_rate*t)/(1-exp(-trunc_time*init_exp_rate));
    
    return prob_init;
}
// (2a.I) Function to initialize the starting number of infectious cells (at the beginning, all infected cells are infectious status=2)
list <int> initInfected(int nbr, list<int> J, vector<int> grid_id, int *no_clust, int t){
	int posID;
    int nbr_seeds = nbr;
	while (nbr>0){
		posID=randID(grid_id);
        if ((*hepaticlayer[posID]).status==0){
			hepaticlayer[posID] -> setStatus(1);
            hepaticlayer[posID] -> setIntraVirusRNA(0);
            hepaticlayer[posID] -> setInfectType(1);
            hepaticlayer[posID] -> setStatusTime(t);
            hepaticlayer[posID] -> setIT(t);

            if (nbr==nbr_seeds) {
                (*no_clust)++;
                hepaticlayer[posID] -> setClusterType(*no_clust);
            }
            else {
                GridPos posvec = calcPosition(posID);
                vector<int> neighvec = returnNeighbrs(posvec.vec[0],posvec.vec[1]);
                for (unsigned int k=0;k<neighvec.size();k++){
                    if((*hepaticlayer[neighvec[k]]).clusterType!=0){
                        hepaticlayer[posID] -> setClusterType((*hepaticlayer[neighvec[k]]).clusterType);  // cell gets cluster id of neighbour
                        break;
                    }
                }
                if ((*hepaticlayer[posID]).clusterType==0) {
                    (*no_clust)++;
                    hepaticlayer[posID] -> setClusterType(*no_clust);  // cell gets new cluster id
                }
            }
			J.push_back((*hepaticlayer[posID]).id);
			nbr--;
		}
	}
	return J;
}



// ############################################################### // ###############################################################
// ####### SPREAD OF INFECTION ####### SPREAD OF INFECTION ####### SPREAD OF INFECTION ####### SPREAD OF INFECTION ##################

// FUNCTIONS FOR CELL-TO-CELL TRANSMISSION
// (2b.I) Function to calculate the probability of a cell to infect by cell-to-cell transmission
double probInfectCC(int id,double prob_infectCC,double frac_HCV){
	double probInf=prob_infectCC;
	
    probInf=frac_HCV*probInf*((*hepaticlayer[id]).IntraVirusRNA);
    if (probInf>1){
        probInf=1;
    }
	return probInf;
}


// ################################################################################################# //
// FUNCTIONS FOR INTRACELLULAR VIRAL DYNAMICS
// (2b.i) Function to calculate the intracellular positive and negative stranded HCV RNA
// I=list of infectious cells
list <int> updateIntraVirusConc(list<int> I,int t,double rate_prod,double Rcap,double rate_export,double rate_degrade, double frac_HCV){
                                         
    list<int>::iterator j;
    j=I.begin();
    int length=I.size();					// fix the length as list is updated
                                         
    for (int r=0;r<length;r++){
        double extraConcAdd=frac_HCV*rate_export*(*hepaticlayer[*j]).IntraVirusRNA;
        viralGrid[*j] -> addVirus(extraConcAdd);
        hepaticlayer[*j] -> updateIntraVirusRNA(rate_prod,Rcap,rate_export,rate_degrade);

        j++;
    }
    return I;
}

// (2b.ii) Function to spread infection by cell-to-cell transmission and/or diffusion of cell free virus
// J=list of infected cells
// I=list of infectious cells
// ,double prob_budDiff,double replTime,
list <int> spreadInfection_CC(list<int> I,list<int>* J, list<int>* K,double *dummy,double *dummyDIST,double prob_infectCC,double frac_HCV,int t,double R0){
	
	int count=0;                            // maximal nbr of neighbours in 2D = maximal number of tries to place an infected cell
	double probInfect=0;					// probability to infect a cell
	list<int>::iterator j;
	j=I.begin();
	int length=I.size();					// fix the length as list is updated
    
	for (int r=0;r<length;r++){
        vector<int> neigh_uninf_cells;
        /* cell-to-cell transmission */
        probInfect=probInfectCC(*j,prob_infectCC,frac_HCV);
        randbin(dummy,probInfect);
        GridPos posj=calcPosition(*j);
        
        if (*dummy==1){
            count=0;
            vector<int> neighcells;
            /* look for an uninfected neighbouring cell to infect */
            neighcells=returnNeighbrs(posj.vec[0],posj.vec[1]);    // get neigbours
            for (unsigned int i=0;i<neighcells.size();i++){                          // check all neighbours for infection status
                if ((*hepaticlayer[neighcells[i]]).status==0){
                    neigh_uninf_cells.push_back(neighcells[i]);
                    count++;
                }
            }
            if (count>0) {
                /* we have at least one uninfected neighbour -> sample one of those */
                randuniform(dummy,0,count);
                int sample=*dummy;
                hepaticlayer[neigh_uninf_cells[sample]] -> setStatus(1);
                hepaticlayer[neigh_uninf_cells[sample]] -> setStatusTime(t);
                hepaticlayer[neigh_uninf_cells[sample]] -> setIT(t);
                hepaticlayer[neigh_uninf_cells[sample]] -> setID(neigh_uninf_cells[sample]);
                hepaticlayer[neigh_uninf_cells[sample]] -> setIntraVirusRNA(0);
                hepaticlayer[neigh_uninf_cells[sample]] -> setInfectType(5);
                hepaticlayer[neigh_uninf_cells[sample]] -> setClusterType((*hepaticlayer[*j]).clusterType);
                /* update infected list */
                (*J).push_back((*hepaticlayer[neigh_uninf_cells[sample]]).id);
                
                /* Cell that infected goes to dormant state and intracellular RNA concentration is reduced by R0 */
                hepaticlayer[*j] -> setStatus(4);
                hepaticlayer[*j] -> setStatusTime(t);
                hepaticlayer[*j] -> reduceIntraVirusRNA(R0,R0);
                (*K).push_back((*hepaticlayer[*j]).id);
                I.erase(j);
                j--;
            }
		}
        j++;
	}
	return I;
}

// (2c.) Function to calculate new infected cells based on the diffusing extracellular virus
list<int> spreadInfection_DIFF(list<int> J, vector<int> grid_id, double prob_infectDIFF, int t,double *dummy,double R0){
	double probInfect=prob_infectDIFF;
	double IFN_eff=0, diff=0, subtract=1;
    vector<int>::iterator j;
    j=grid_id.begin();
    for (unsigned int i=0;i<grid_id.size();i++) {
        if((*hepaticlayer[*j]).status==0 || (*hepaticlayer[*j]).infectType==5){
            probInfect=prob_infectDIFF*(*viralGrid[*j]).conc;  // only virus on grid point can infect cell
            if (probInfect>1){
                probInfect=1;
            }
            randbin(dummy,probInfect);
            if(*dummy==1){
                hepaticlayer[*j] -> setStatus(1);
                hepaticlayer[*j] -> setStatusTime(t);
                hepaticlayer[*j] -> setIT(t);
                hepaticlayer[*j] -> setIntraVirusRNA(0);
                
                if ((*hepaticlayer[*j]).infectType==5) {
                    hepaticlayer[*j] -> setInfectType(4);
                    //              do not update infected list here as cells with infectType=5 were already included in list J (in spreadInfection_CC)
                }
                else {
                    hepaticlayer[*j] -> setInfectType(3);
                    // update infected list
                    J.push_back((*hepaticlayer[*j]).id);
                }
                
                // reduce viral concentration
                subtract=R0;
                if ((*viralGrid[*j]).conc>=R0) {
                    viralGrid[*j] -> subtractVirus(R0);
                }
                else {
                    GridPos posj = calcPosition(*j);
                    vector<int> neighvec;
                    neighvec = returnNeighbrs(posj.vec[0],posj.vec[1]);
                    neighvec = sample(neighvec);
                    // Subtract virus after free diffusion infection
                    for (unsigned int k=0;k<neighvec.size();k++){
                        diff=(*viralGrid[neighvec[k]]).conc-subtract;
                        if (diff<0){
                            viralGrid[neighvec[k]] -> setConc(0);
                            subtract=(-1.0)*diff;
                        }
                        else {
                            viralGrid[neighvec[k]] -> setConc(diff);
                            subtract=0;
                        }
                    }
                }
            }
        }
        j++;
	}
	return J;
}


// (2d.) Function to calculate the total extracellular viral load in the system
Vector TotalViralLoad(vector<int> grid_id, int s, int t,int saveT){
    vector<int>::iterator j;
    j=grid_id.begin();
	double load=0;
    double loadIntraRNA=0;
	double test=0;
	
	test=t%saveT;
	Vector ret;
	
	
	for (unsigned int i=0;i<grid_id.size();i++){
        load=load+(*viralGrid[*j]).conc;
        loadIntraRNA=loadIntraRNA+(*hepaticlayer[*j]).IntraVirusRNA;
        j++;
	}
	ret.vec[0]=load;
    ret.vec[1]=loadIntraRNA;
	return ret;
}


// (2e.) Cell proliferation of uninfected hepatocytes
list <int> prolif_cells(list<int> E, double *dummy, double prolif_time, int t){
    int count=0;
    list<int>::iterator j;
    j=E.begin();
    int length=E.size();					// fix the length as list is updated
    
    for (int r=0;r<length;r++){
        vector<int> neigh_uninf_cells;
        vector<double> t_prolif_vec;
        count=0;
        vector<int> neighcells;
        GridPos posj=calcPosition(*j);
        neighcells=returnNeighbrs(posj.vec[0],posj.vec[1]);    // get neigbours
        /* look for an uninfected neighbouring cell for proliferation */
        for (unsigned int i=0;i<neighcells.size();i++){                          // check all neighbours for infection status
            if ((*hepaticlayer[neighcells[i]]).status==0){
                neigh_uninf_cells.push_back(neighcells[i]);
                t_prolif_vec.push_back((*hepaticlayer[neighcells[i]]).statusTime); // Put proliferation times of uninfected neighbours in vector
                count++;
            }
        }
        if (count>0){
            double t_prolif_min=*min_element(t_prolif_vec.begin(),t_prolif_vec.end());  // get smallest proliferation time, i.e., time that cell wanted to proliferate the longest
            if(t_prolif_min<t){
                int id_min=neigh_uninf_cells[distance(t_prolif_vec.begin(),min_element(t_prolif_vec.begin(),t_prolif_vec.end()))];  // get id of cell that wants to proliferate the longest
                randnorm(dummy,prolif_time,0.1*prolif_time);
                double t_prolif = t+*dummy; // Calculate new proliferation time of old cell
                hepaticlayer[id_min] -> setStatusTime(t_prolif);  // Set new proliferation time of old cell
                /* New cell */
                hepaticlayer[*j] -> setStatus(0);
                randnorm(dummy,prolif_time,0.1*prolif_time);
                double t_prolif2 = t+*dummy; // Calculate proliferation time of new cell
                hepaticlayer[*j] -> setStatusTime(t_prolif2); // Set proliferation time of new cell
                /* update list of empty cells */
                E.erase(j);
                j--;
            }
        }
        j++;
    }
    return E;
}


// ############################################################### // ###############################################################
// ####### DIFFUSING VIRAL LOAD ####### DIFFUSING VIRAL LOAD ####### DIFFUSING VIRAL LOAD ####### DIFFUSING VIRAL LOAD ##############

// (2f.) Function to update the viral concentration, i.e., assuming diffusion/ diffusion with drift
// (compare to Funk et al., JTB 2005, Eq.2)
// average the concentration over the space -> include drift
void updateViralConcentration(vector<int> grid_id, double coupling,double rate_dieV,double runsV,double *dummy,double E2_0,double *E2,double degr_e2){
    vector<int>::iterator j;

	double concentration=0,prob_run=0,IFNconcentration=0,concE2=*E2;
	
    // In case no anti-E2 is administered, we do not want subtract anything from the extracellular viral concentration
    if (E2_0==0){
        E2_0=1;
    }
	while (runsV>0){
		
		if (runsV>=1){
			prob_run=1;
			
		}
		else {
			prob_run=runsV;
		}
		
		randbin(dummy,prob_run);
		if(*dummy==1){
            j=grid_id.begin();
			for (unsigned int i=0;i<grid_id.size();i++){
                concentration=(*viralGrid[*j]).conc;
                
                GridPos posj = calcPosition(*j);
                vector<int> neighvec;
                neighvec = returnNeighbrs(posj.vec[0],posj.vec[1]);
                for (unsigned int k=0;k<neighvec.size();k++){
                    /* homogeneous coupling, simple diffusion */
                    concentration=concentration-((coupling/6.0)*((*viralGrid[*j]).conc-(*viralGrid[neighvec[k]]).conc));
                }
                if (concentration<0){
                    concentration=0;
                }
                if (runsV<=1) {
                    viralGrid[*j] -> setConcII(concentration*(1.0-rate_dieV)*(1-((*E2)/E2_0)));
                    concE2=concE2-degr_e2*concentration*((*E2)/E2_0);  // Decrease anti-E2 concentration dependent on extracellular viral concentration
                }
                else {
                    viralGrid[*j] -> setConcII(concentration);
                }
                j++;
			}
		}
        
        // In case there is no diffusion run, there is still degradation
        else {
            j=grid_id.begin();
            for (unsigned int i=0;i<grid_id.size();i++){
                concentration=(*viralGrid[*j]).conc;
                viralGrid[*j] -> setConcII(concentration*(1.0-rate_dieV)*(1-((*E2)/E2_0)));
                concE2=concE2-degr_e2*concentration*((*E2)/E2_0);  // Decrease anti-E2 concentration dependent on extracellular viral concentration
                j++;
            }
        }
        
        // Update extracellular viral concentration after diffusion ran through the whole grid
        j=grid_id.begin();
        for (unsigned int i=0;i<grid_id.size();i++){
            viralGrid[*j] -> updateConc();
            j++;
        }
		runsV--;
	}
    // Update anti-E2 concentration
    if (concE2<0){
        *E2=0;
    }
    else {
        *E2=concE2;
    }
}

// ############################################################### // ###############################################################
// ####### VITAL DYNAMICS OF HEPATOCYTES ####### VITAL DYNAMICS OF HEPATOCYTES ####### VITAL DYNAMICS OF HEPATOCYTES ################
// ####### UPDATE OF HEPATOCYTE LATTICE ####### UPDATE OF HEPATOCYTE LATTICE ####### UPDATE OF HEPATOCYTE LATTICE ###################


// (3a.) Funtion to update the newly infected hepatocytes
list<int> updateNewlyInfected_J(list<int> J,list<int>* K,int t,int* no_clust,double R0){
    list<int>::iterator j;
    j=J.begin();
    int length=J.size();					// fix the length as list is updated
    for (int r=0;r<length;r++){
        /* Set infectType of cells infected by cell to cell to 2 */
        if ((*hepaticlayer[*j]).infectType==5) {
            hepaticlayer[*j] -> setInfectType(2);
        }
        /*Set clusterType for cells infected by FD */
        if ((*hepaticlayer[*j]).infectType==3 && (*hepaticlayer[*j]).clusterType==0) {
            GridPos posvec = calcPosition(*j);
            vector<int> neighvec = returnNeighbrs(posvec.vec[0],posvec.vec[1]);
            for (unsigned int k=0;k<neighvec.size();k++){
                if((*hepaticlayer[neighvec[k]]).clusterType!=0){
                    hepaticlayer[*j] -> setClusterType((*hepaticlayer[neighvec[k]]).clusterType);  // cell gets cluster id of neighbour
                    break;
                }
            }
            if ((*hepaticlayer[*j]).clusterType==0) {
                (*no_clust)++;
                hepaticlayer[*j] -> setClusterType(*no_clust);  // cell gets new cluster id
            }
        }
        hepaticlayer[*j] -> setStatus(4);
        hepaticlayer[*j] -> setIntraVirusRNA(R0);
        /* increase the infectious-list */
        (*K).push_back((*hepaticlayer[*j]).id);
        /* reduce the infected-list */
        J.erase(j);
        j--;
        j++;
    }
    return J;
}

// (3b.) Funtion to update the infected hepatocytes (lifetime  + getting infectious)
list<int> updateInfected_K(list<int> K,list<int>* I,int t,double prob_dieJ,double prob_infinf, double *dummy, double R0){
    
    list<int>::iterator j;
    j=K.begin();
    int length=K.size();					// fix the length as list is updated
    
    for (int r=0;r<length;r++){
        /* does the infected hepatocyte die ? */
        randbin(dummy,prob_dieJ);
        if (*dummy==1){
            //			outTEST<<"we are here"<<endl;
            hepaticlayer[*j] -> setStatus(3);
            hepaticlayer[*j] -> setStatusTime(t);
            /* reduce the infected-list */
            K.erase(j);
            j--;
        }
        else {
            
            /* does the infected hepatocyte get infectious? */
            randbin(dummy,prob_infinf);
            if (*dummy==1){
                hepaticlayer[*j] -> setStatus(2);
                hepaticlayer[*j] -> setStatusTime(t);
                hepaticlayer[*j] -> setIIT(t);
                /* increase the infectious-list */
                (*I).push_back((*hepaticlayer[*j]).id);
                /* reduce the infected-list */
                K.erase(j);
                j--;
            }
        }
        j++;
    }
    return K;
}



// (3c.) Function to update uninfected hepatocytes
Vector updateUninfected(hepatocyte *h,Vector v,int t,double prob_dieUI,double *dummy){
	randbin(dummy,prob_dieUI);
	if (*dummy==1){
		h -> setStatus(3);
		h -> setStatusTime(t);
		v.vec[5]++;
	}
	else {
		v.vec[2]++;
	}
	return v;
}


// (3d.) Function to update the infection type for all infected cells
Vector updateInfectType(list<int> I,list<int> J){
	
	Vector v;
	v=setZerovector(v);
	
    list<int>::iterator i;
	i=I.begin();                            // Run through list of infectious cells
    int lengthI=I.size();					// fix the length as list is updated
	
	for (int r1=0;r1<lengthI;r1++){
        switch ((*hepaticlayer[*i]).infectType){
            case 1: v.vec[0]++; break;
            case 2: v.vec[1]++; break;
            case 3: v.vec[2]++; break;
            case 4: v.vec[3]++; break;
            case 5: v.vec[4]++;
        }
        i++;
    }
    
    list<int>::iterator j;
	j=J.begin();                            // Run through list of infected cells
    int lengthJ=J.size();					// fix the length as list is updated
	
	for (int r=0;r<lengthJ;r++){
        switch ((*hepaticlayer[*j]).infectType){
            case 1: v.vec[0]++; break;
            case 2: v.vec[1]++; break;
            case 3: v.vec[2]++; break;
            case 4: v.vec[3]++; break;
            case 5: v.vec[4]++;
        }
        j++;
    }

	return v;
}


// ############################################################### // ###############################################################
// ############################################################### // ###############################################################







// ############################################################### // ###############################################################
// FUNCTIONS TO PERFORM STATISTICS AND TO SAVE OUTCOMES

// (4a.) Function to write the elements of an integer-list into a file (separately for each list type needed)
void saveList(list<int> L,int s, int t,int dumType){
	
	int length=L.size();
	int count=0;
	list<int>::iterator i;
	i=L.begin();
	switch(dumType){
		case 4: outHEPinf<<s<<","<<t;
            while (count<length){
                outHEPinf<<","<<(*i);
                count++;
                i++;
            }
            outHEPinf<<endl;
			break;
		case 2: outHEPinfectious<<s<<","<<t;
			while (count<length){
				outHEPinfectious<<","<<(*i);
				count++;
				i++;
			}
			outHEPinfectious<<endl;
			break;
		case 3: outEmpty<<s<<","<<t;
			while (count<length){
				outEmpty<<","<<(*i);
				count++;
				i++;
			}
			outEmpty<<endl;
			break;
	}
}

// (4b.) Function to save the statistic of the hepaticlayer
void saveHepStat(Vector statVec){
	outHEPstat<<statVec.vec[0];
	for (int i=1;i<15;i++){
		outHEPstat<<","<<statVec.vec[i];
	}
	outHEPstat<<endl;
}

// (4c.) Function to save the type of infection of infected and infectious cells
void saveInfType(vector<int> grid_id){
    vector<int>::iterator j;
    j=grid_id.begin();
    for (unsigned int i=0;i<grid_id.size();i++){
        if ((*hepaticlayer[*j]).status==0 || (*hepaticlayer[*j]).status==3) {
            outInfectClusterType<<(*hepaticlayer[*j]).id<<","<<0<<","<<0<<endl;
        }
        else {outInfectClusterType<<(*hepaticlayer[*j]).id<<","<<(*hepaticlayer[*j]).infectType<<","<<(*hepaticlayer[*j]).clusterType<<endl;
        }
        j++;
    }
}

// (4d.) Function to save the extracellular viral grid (not used right now, as it needs too much space to save)
/*void saveVIRALGRID(vector<int> grid_id,int t,int s){
    outVIRALGRID<<s<<","<<t;
    vector<int>::iterator j;
    j=grid_id.begin();
    for (unsigned int i=0;i<grid_id.size();i++){
        outVIRALGRID<<","<<(*viralGrid[*j]).conc;
        j++;
    }
    outVIRALGRID<<endl;
}*/

// (4e.) Function to save the intracellular viral concentration for each cell (not used right now, as it needs too much space to save)
/*void saveHEPINFO(vector<int> grid_id,int t,int s){
    vector<int>::iterator j;
    j=grid_id.begin();
    for (unsigned int i=0;i<grid_id.size();i++){
        if ((*hepaticlayer[*j]).status!=0){
            outHEPINFO<<s<<","<<t<<",";
            outHEPINFO<<(*hepaticlayer[*j]).id<<","<<(*hepaticlayer[*j]).IntraVirusRNA<<endl;
        }
        j++;
    }
}*/

